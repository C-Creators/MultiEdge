---
import AdminLayout from '../../layouts/AdminLayout.astro';
import { createServerClient } from '../../lib/supabase';
import { translations } from '../../i18n/translations';

// Check authentication
const supabase = createServerClient(Astro.cookies);
const accessToken = Astro.cookies.get('sb-access-token')?.value;
const refreshToken = Astro.cookies.get('sb-refresh-token')?.value;

let session = null;

if (accessToken && refreshToken) {
  const { data } = await supabase.auth.setSession({
    access_token: accessToken,
    refresh_token: refreshToken
  });
  session = data.session;
}

if (!session) {
  return Astro.redirect('/admin/login');
}

// Fetch content from Supabase
const { data: contentData } = await supabase
  .from('site_content')
  .select('*')
  .order('section', { ascending: true });

// Create a map for quick lookup
const dbContent = new Map<string, { en: string; es: string; id: string }>();
contentData?.forEach(item => {
  dbContent.set(`${item.section}.${item.key}`, {
    en: item.en,
    es: item.es,
    id: item.id
  });
});

// Define sections with their display names and icons
const sectionConfig: Record<string, { name: string; icon: string; description: string }> = {
  nav: { name: 'Navigation', icon: 'menu', description: 'Main menu and navigation links' },
  drawer: { name: 'Mobile Menu', icon: 'smartphone', description: 'Mobile drawer menu items' },
  hero: { name: 'Hero Section', icon: 'home', description: 'Main headline and intro text' },
  about: { name: 'About', icon: 'info', description: 'About Duplifinance section' },
  philosophy: { name: 'Philosophy', icon: 'brain', description: 'Investment philosophy content' },
  systems: { name: 'Systems', icon: 'cpu', description: 'Automated systems section' },
  brokers: { name: 'Brokers', icon: 'building-2', description: 'Broker flexibility section' },
  bot: { name: 'Bot Details', icon: 'bot', description: 'Bot performance metrics' },
  audience: { name: 'Audience', icon: 'users', description: 'Target audience section' },
  finalCta: { name: 'Final CTA', icon: 'megaphone', description: 'Final call-to-action band' },
  register: { name: 'Registration', icon: 'user-plus', description: 'Registration popup content' },
  faq: { name: 'FAQ', icon: 'help-circle', description: 'Frequently asked questions' },
  footer: { name: 'Footer', icon: 'file-text', description: 'Footer links and copyright' }
};

// Helper to get nested value
function getNestedValue(obj: any, path: string): string {
  return path.split('.').reduce((acc, part) => acc?.[part], obj) || '';
}

// Content item interface
interface ContentItem {
  fullKey: string;
  key: string;
  en: string;
  es: string;
  fromDb: boolean;
}

// Process translations into grouped content
const contentBySection: Record<string, ContentItem[]> = {};

function processSection(sectionObj: any, sectionName: string, prefix = '') {
  if (!contentBySection[sectionName]) {
    contentBySection[sectionName] = [];
  }
  
  for (const [key, value] of Object.entries(sectionObj)) {
    const itemKey = prefix ? `${prefix}.${key}` : key;
    const fullKey = `${sectionName}.${itemKey}`;
    
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      processSection(value, sectionName, itemKey);
    } else if (typeof value === 'string') {
      const dbItem = dbContent.get(fullKey);
      const esValue = getNestedValue((translations.es as any)[sectionName], itemKey);
      
      contentBySection[sectionName].push({
        fullKey,
        key: itemKey,
        en: dbItem?.en || value,
        es: dbItem?.es || esValue || '',
        fromDb: !!dbItem
      });
    }
  }
}

// Process each section
for (const [sectionName, sectionContent] of Object.entries(translations.en)) {
  if (typeof sectionContent === 'object' && sectionContent !== null) {
    processSection(sectionContent, sectionName);
  }
}
---

<AdminLayout title="Content Editor">
  <div class="content-editor">
    <!-- Header -->
    <div class="editor-header">
      <div class="header-left">
        <div class="search-box">
          <i data-lucide="search"></i>
          <input type="text" id="searchInput" placeholder="Search content..." />
        </div>
        <select id="sectionFilter" class="filter-select">
          <option value="all">All Sections</option>
          {Object.entries(sectionConfig).map(([key, config]) => (
            <option value={key}>{config.name}</option>
          ))}
        </select>
      </div>
      <div class="header-right">
        <button id="syncBtn" class="btn btn-outline">
          <i data-lucide="download"></i>
          Import from File
        </button>
        <button id="saveBtn" class="btn btn-primary" disabled>
          <i data-lucide="save"></i>
          Save Changes
          <span id="changeCount" class="badge">0</span>
        </button>
      </div>
    </div>

    <!-- Sections -->
    <div class="sections-list">
      {Object.entries(contentBySection).map(([section, items]) => {
        const config = sectionConfig[section] || { name: section, icon: 'file', description: '' };
        return (
          <div class="section-card" data-section={section}>
            <div class="section-header" data-toggle="section">
              <div class="section-info">
                <div class="section-icon">
                  <i data-lucide={config.icon}></i>
                </div>
                <div>
                  <h3>{config.name}</h3>
                  <p>{config.description}</p>
                </div>
              </div>
              <div class="section-meta">
                <span class="count-badge">{items.length} items</span>
                <button class="toggle-btn">
                  <i data-lucide="chevron-down"></i>
                </button>
              </div>
            </div>
            
            <div class="section-body collapsed">
              {items.map(item => (
                <div class="content-item" data-key={item.fullKey}>
                  <div class="item-label">
                    <code>{item.key}</code>
                    {item.fromDb && <span class="edited-tag">Edited</span>}
                  </div>
                  <div class="item-fields">
                    <div class="field-group">
                      <label><span class="flag">ðŸ‡ºðŸ‡¸</span> English</label>
                      <textarea 
                        class="field-input"
                        data-key={item.fullKey}
                        data-lang="en"
                        rows={Math.max(2, Math.ceil(item.en.length / 60))}
                      >{item.en}</textarea>
                    </div>
                    <div class="field-group">
                      <label><span class="flag">ðŸ‡ªðŸ‡¸</span> Spanish</label>
                      <textarea 
                        class="field-input"
                        data-key={item.fullKey}
                        data-lang="es"
                        rows={Math.max(2, Math.ceil(item.es.length / 60))}
                      >{item.es}</textarea>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      })}
    </div>
  </div>

  <!-- Floating Save Bar -->
  <div id="floatingBar" class="floating-bar hidden">
    <span><strong id="floatingCount">0</strong> unsaved changes</span>
    <button id="floatingSaveBtn" class="btn btn-primary btn-sm">
      <i data-lucide="save"></i>
      Save All
    </button>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast hidden">
    <i data-lucide="check-circle"></i>
    <span id="toastMsg">Saved!</span>
  </div>
</AdminLayout>

<script>
  // Track changes
  const changes = new Map<string, { en: string; es: string }>();
  const originals = new Map<string, { en: string; es: string }>();

  // Store original values on load
  document.querySelectorAll('.content-item').forEach(item => {
    const key = (item as HTMLElement).dataset.key!;
    const enInput = item.querySelector('[data-lang="en"]') as HTMLTextAreaElement;
    const esInput = item.querySelector('[data-lang="es"]') as HTMLTextAreaElement;
    originals.set(key, { en: enInput.value, es: esInput.value });
  });

  // Toggle sections
  document.querySelectorAll('.section-header').forEach(header => {
    header.addEventListener('click', () => {
      const card = header.closest('.section-card')!;
      const body = card.querySelector('.section-body')!;
      const icon = header.querySelector('.toggle-btn i')!;
      
      body.classList.toggle('collapsed');
      icon.setAttribute('data-lucide', body.classList.contains('collapsed') ? 'chevron-down' : 'chevron-up');
      // @ts-ignore
      lucide.createIcons();
    });
  });

  // Handle input changes
  document.querySelectorAll('.field-input').forEach(input => {
    input.addEventListener('input', () => {
      const textarea = input as HTMLTextAreaElement;
      const key = textarea.dataset.key!;
      const item = textarea.closest('.content-item')!;
      
      const enInput = item.querySelector('[data-lang="en"]') as HTMLTextAreaElement;
      const esInput = item.querySelector('[data-lang="es"]') as HTMLTextAreaElement;
      
      const original = originals.get(key)!;
      const current = { en: enInput.value, es: esInput.value };
      
      if (current.en !== original.en || current.es !== original.es) {
        changes.set(key, current);
        item.classList.add('modified');
      } else {
        changes.delete(key);
        item.classList.remove('modified');
      }
      
      updateUI();
    });
  });

  function updateUI() {
    const count = changes.size;
    const saveBtn = document.getElementById('saveBtn') as HTMLButtonElement;
    const badge = document.getElementById('changeCount')!;
    const floatingBar = document.getElementById('floatingBar')!;
    const floatingCount = document.getElementById('floatingCount')!;

    badge.textContent = count.toString();
    saveBtn.disabled = count === 0;
    floatingCount.textContent = count.toString();
    floatingBar.classList.toggle('hidden', count === 0);
  }

  // Save function
  async function saveChanges() {
    if (changes.size === 0) return;

    const btns = [
      document.getElementById('saveBtn'),
      document.getElementById('floatingSaveBtn')
    ] as HTMLButtonElement[];

    btns.forEach(btn => {
      btn.disabled = true;
      btn.innerHTML = '<i data-lucide="loader"></i> Saving...';
    });

    try {
      const payload: Record<string, { en: string; es: string }> = {};
      changes.forEach((val, key) => payload[key] = val);

      const res = await fetch('/api/content/update', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (res.ok) {
        showToast('All changes saved successfully!', false);
        
        // Update originals
        changes.forEach((val, key) => originals.set(key, { ...val }));
        changes.clear();
        
        document.querySelectorAll('.content-item.modified').forEach(item => {
          item.classList.remove('modified');
          item.classList.add('saved');
          setTimeout(() => item.classList.remove('saved'), 2000);
        });
        
        updateUI();
      } else {
        showToast('Failed to save changes', true);
      }
    } catch (e) {
      showToast('Error saving changes', true);
    }

    btns.forEach(btn => {
      btn.disabled = false;
      btn.innerHTML = '<i data-lucide="save"></i> Save';
    });
    // @ts-ignore
    lucide.createIcons();
  }

  document.getElementById('saveBtn')?.addEventListener('click', saveChanges);
  document.getElementById('floatingSaveBtn')?.addEventListener('click', saveChanges);

  // Search
  document.getElementById('searchInput')?.addEventListener('input', (e) => {
    filter((e.target as HTMLInputElement).value, (document.getElementById('sectionFilter') as HTMLSelectElement).value);
  });

  document.getElementById('sectionFilter')?.addEventListener('change', (e) => {
    filter((document.getElementById('searchInput') as HTMLInputElement).value, (e.target as HTMLSelectElement).value);
  });

  function filter(query: string, section: string) {
    const q = query.toLowerCase();
    
    document.querySelectorAll('.section-card').forEach(card => {
      const sec = (card as HTMLElement).dataset.section!;
      const matchSection = section === 'all' || sec === section;
      
      if (!matchSection) {
        (card as HTMLElement).style.display = 'none';
        return;
      }
      
      let visible = 0;
      card.querySelectorAll('.content-item').forEach(item => {
        const key = (item as HTMLElement).dataset.key?.toLowerCase() || '';
        const text = item.textContent?.toLowerCase() || '';
        const match = !q || key.includes(q) || text.includes(q);
        (item as HTMLElement).style.display = match ? '' : 'none';
        if (match) visible++;
      });
      
      (card as HTMLElement).style.display = visible > 0 ? '' : 'none';
      
      // Auto expand if filtering
      if (q && visible > 0) {
        card.querySelector('.section-body')?.classList.remove('collapsed');
      }
    });
  }

  // Import from file
  document.getElementById('syncBtn')?.addEventListener('click', async () => {
    if (!confirm('Import all translations from file to database?\n\nExisting edits will NOT be overwritten.')) return;

    const btn = document.getElementById('syncBtn') as HTMLButtonElement;
    btn.disabled = true;
    btn.innerHTML = '<i data-lucide="loader"></i> Importing...';

    try {
      const res = await fetch('/api/content/sync', { method: 'POST' });
      if (res.ok) {
        const data = await res.json();
        showToast(`Imported ${data.count} items!`, false);
        setTimeout(() => location.reload(), 1500);
      } else {
        showToast('Import failed', true);
      }
    } catch (e) {
      showToast('Error importing', true);
    }

    btn.disabled = false;
    btn.innerHTML = '<i data-lucide="download"></i> Import from File';
    // @ts-ignore
    lucide.createIcons();
  });

  // Toast
  function showToast(msg: string, isError: boolean) {
    const toast = document.getElementById('toast')!;
    document.getElementById('toastMsg')!.textContent = msg;
    toast.classList.remove('hidden');
    toast.classList.toggle('error', isError);
    setTimeout(() => toast.classList.add('hidden'), 3000);
  }

  // Warn on exit
  window.addEventListener('beforeunload', (e) => {
    if (changes.size > 0) {
      e.preventDefault();
      e.returnValue = '';
    }
  });
</script>

<style>
  .content-editor {
    max-width: 1100px;
    margin: 0 auto;
  }

  .editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    margin-bottom: 24px;
    padding-bottom: 20px;
    border-bottom: 1px solid #e5e7eb;
    flex-wrap: wrap;
  }

  .header-left {
    display: flex;
    gap: 12px;
    flex: 1;
    min-width: 300px;
  }

  .search-box {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 0 14px;
    flex: 1;
    max-width: 320px;
  }

  .search-box i { width: 18px; height: 18px; color: #9ca3af; }

  .search-box input {
    border: none;
    outline: none;
    padding: 11px 0;
    flex: 1;
    font-size: 14px;
    background: transparent;
  }

  .filter-select {
    padding: 11px 14px;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    font-size: 14px;
    background: #fff;
    cursor: pointer;
    min-width: 160px;
  }

  .header-right { display: flex; gap: 10px; }

  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 11px 18px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    border: none;
    transition: all 0.15s;
  }

  .btn i { width: 16px; height: 16px; }

  .btn-primary {
    background: #1a1a2e;
    color: #fff;
  }

  .btn-primary:hover:not(:disabled) { background: #2d2d44; }
  .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-outline {
    background: #fff;
    color: #374151;
    border: 1px solid #e5e7eb;
  }

  .btn-outline:hover { background: #f9fafb; border-color: #d1d5db; }

  .btn-sm { padding: 8px 14px; font-size: 13px; }

  .badge {
    background: #c9a227;
    color: #fff;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 12px;
    min-width: 20px;
    text-align: center;
  }

  .sections-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .section-card {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    overflow: hidden;
    border: 1px solid #e5e7eb;
  }

  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    cursor: pointer;
    transition: background 0.15s;
  }

  .section-header:hover { background: #f9fafb; }

  .section-info {
    display: flex;
    align-items: center;
    gap: 14px;
  }

  .section-icon {
    width: 42px;
    height: 42px;
    background: linear-gradient(135deg, #fef3c7, #fde68a);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .section-icon i { width: 20px; height: 20px; color: #b45309; }

  .section-info h3 {
    font-size: 16px;
    font-weight: 600;
    color: #1a1a2e;
    margin: 0 0 2px;
  }

  .section-info p {
    font-size: 13px;
    color: #6b7280;
    margin: 0;
  }

  .section-meta {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .count-badge {
    font-size: 12px;
    color: #6b7280;
    background: #f3f4f6;
    padding: 4px 10px;
    border-radius: 6px;
  }

  .toggle-btn {
    background: none;
    border: none;
    padding: 6px;
    cursor: pointer;
    color: #9ca3af;
    border-radius: 6px;
  }

  .toggle-btn:hover { background: #e5e7eb; color: #374151; }

  .section-body {
    border-top: 1px solid #e5e7eb;
    transition: all 0.2s;
  }

  .section-body.collapsed { display: none; }

  .content-item {
    padding: 18px 20px;
    border-bottom: 1px solid #f3f4f6;
    transition: all 0.15s;
  }

  .content-item:last-child { border-bottom: none; }
  .content-item:hover { background: #fafafa; }

  .content-item.modified {
    background: #fffbeb;
    border-left: 3px solid #c9a227;
  }

  .content-item.saved {
    background: #ecfdf5;
    border-left: 3px solid #10b981;
  }

  .item-label {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
  }

  .item-label code {
    font-size: 12px;
    color: #6b7280;
    background: #f3f4f6;
    padding: 4px 10px;
    border-radius: 5px;
    font-family: 'SF Mono', Monaco, Consolas, monospace;
  }

  .edited-tag {
    font-size: 10px;
    background: #dbeafe;
    color: #1d4ed8;
    padding: 3px 8px;
    border-radius: 4px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  .item-fields {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }

  .field-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .field-group label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    font-weight: 600;
    color: #4b5563;
  }

  .flag { font-size: 14px; }

  .field-input {
    padding: 10px 12px;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    min-height: 44px;
    line-height: 1.5;
    transition: all 0.15s;
  }

  .field-input:focus {
    outline: none;
    border-color: #c9a227;
    box-shadow: 0 0 0 3px rgba(201, 162, 39, 0.12);
  }

  /* Floating Bar */
  .floating-bar {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 16px;
    background: #1a1a2e;
    color: #fff;
    padding: 12px 20px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.25);
    z-index: 100;
    transition: all 0.25s;
  }

  .floating-bar.hidden {
    opacity: 0;
    transform: translateX(-50%) translateY(20px);
    pointer-events: none;
  }

  .floating-bar span { font-size: 14px; }

  /* Toast */
  .toast {
    position: fixed;
    top: 24px;
    right: 24px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 14px 20px;
    background: #1a1a2e;
    color: #fff;
    border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    z-index: 1000;
    transition: all 0.25s;
  }

  .toast.hidden {
    opacity: 0;
    transform: translateY(-10px);
    pointer-events: none;
  }

  .toast.error { background: #dc2626; }
  .toast i { width: 20px; height: 20px; }

  @media (max-width: 768px) {
    .editor-header { flex-direction: column; align-items: stretch; }
    .header-left { flex-direction: column; min-width: 0; }
    .search-box { max-width: none; }
    .header-right { justify-content: stretch; }
    .header-right .btn { flex: 1; justify-content: center; }
    .item-fields { grid-template-columns: 1fr; }
    .floating-bar { left: 16px; right: 16px; transform: none; }
    .floating-bar.hidden { transform: translateY(20px); }
  }
</style>
